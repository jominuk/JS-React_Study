# 함수(function)

## 1. 함수란?

- 하나의 특별한 목적의 작업을 수행하도록 설계된 독립적인 블록

```javascript
function add(x, y) {
  return x + y;
}
add(2, 5); // 7
```

## 2. 함수의 정의

- 함수를 호출하기 이전에 인수를 전달받을 매개변수와 실행할 문들, 그리고 반환할 값을 지정하는 것

- 함수를 정의하는 문법

```javascript
function 함수이름 (매개변수1, 매개변수 2,...) {
    함수가 호출되었을 때 실행하고자 하는 실행문
}
```
- 함수 호출
  - 선언(매개변수 parameter)
  - 호출(전달인자 argument)
- 함수 이름은 함수를 구분하는 식별자 이다.
- 매개변수(parameter)란 함수를 호출할 때 인수(argument)로 전달된 값을 함수 내부에서 사용할 수 있게 해주는 변수

```javascript
function add(x, y) {
  //x,y는 이 함수의 매개변수
  return x + y;
}
add(2, 5); // add() 함수에 인수로 2와 3을 전달하여 호출함
```

### 2-1 함수를 정의하는 4가지 방법
```javascript
1. 함수 선언문 (명시적 함수의 선언)

function add(x, y) {
  return x + y;
}
- 함수명이 정의되어 있고, 별도의 할당 명령이 없는 것


2. 함수 표현식 (함수 리터럴)

var add = function (x, y) {
  return x + y;
};

- 정의한 function을 별도의 변수에 할당하는 것
- 익명 함수와 유사

*** [선언식과 표현식의 차이는 호이스팅에서 발생한다.] ***

- 함수 선언식은 함수 전체를 호이스팅하며, 함수 표현식은 별도의 변수에 할당하게 되는데, <br>
  변수는 선언부와 할당부를 나누어 호이스팅 하게 됩니다.


3. function 생성자 함수

var add = new Function("x", "y", "x+y");


4. 화살표 함수 (람다함수)

var add = (x, y) => x + y;

```

## 3. 함수를 사용하는 이유

- 코드의 재사용성이 유용
- 유지보수의 편의성을 높임
- 코드의 신뢰성을 높임
- 코드의 가독성을 향상

## 4. 용어 정리

- 함수를 사용하는 것을 "함수 호출", 즉 "함수를 호출한다"라고 표현
- 함수 호출할 때 솰호 내부에 여러 가지 자료를 넣는데, 이러한 자료를 "매개 변수"
- 최종적으로 나오는 결과를 "리턴값"

### 6-1 익명함수와 선언적 함수의 차이

```익명함수``` 는 순차적인 코드 실행에서 코드가 해당 줄을 읽을 때 생성
```익명함수``` 는 호이스팅 시 위로 올라가지 않고 익명 함수를 저장한 변수만 올라가게 된다.

```javascript
let 익명함수

// 익명 함수를 2번 생성
익명함수 = function () {
  console.log('1번 익명함수')
}
익명함수 = function () {
  console.log('2번 익명함수')
}

익명함수()

//실행결과
[ 2번 익명함수 ]

=======================================================


let 익명함수
익명함수()

// 익명 함수를 2번 생성
익명함수 = function () {
  console.log('1번 익명함수')
}
익명함수 = function () {
  console.log('2번 익명함수')
}

//실행결과
error

// 당연히 익명 함수는 순차적으로 실행시키기에 에러
```

<br/>

```선언적 함수``` 는 순차적인 코드 실행이 일어나기 전에 생성
따라서 ```선언적 함수```는 같은 블록이라면 어디에서 호출해도 무방

```javascript
//선언적 함수를 호출

function 선언적함수 () {
  console.log("1번 함수")
}
function 선언적함수 () {
  console.log("2번 함수")
}

선언적 함수 ()
//실행결과
[ 2번 함수 ]

==============================================
선언적 함수 ()

function 선언적함수 () {
  console.log("1번 함수")
}
function 선언적함수 () {
  console.log("2번 함수")
}


//실행결과
[ 2번 함수 ]

```

### 6-2 둘의 차이

- 익명 함수

  - 순차적인 코드 실행에서 코드가 해당줄을 읽을 때 생성
  - 따라서 위에서 아래로 차례대로 코드가 실행되면서 익명 함수라는 변수에 "2번 익명함수" 가 호출

- 선언적 함수

  - 순차적인 코드 실행이 일어나기 전에 생성
  - 같은 블록이라면 어디에서 함수를 호출해도 무반

```javascript
함수()

함수 = function () {
  consoloe.log("익명함수입니다.")
};

function 함수 () {
  console.log("선언적함수입니다.)
};

함수()

// 출력 결과
선언적함수입니다
익명함수입니다
```

- 상단 함수()의 결과는 ```선언적함수```를 호출하고
- 하단 함수()의 결과는 함수가 함수라는 변수 자체를 덮어쓰기 때문에 익명함수라는 결과를 출력하게 된다.


<br/>

### 화살표 함수에서의 this
```javasciprt
target = 'global happy';

function test(){
	console.log(this.target);
}

const object = {
	target: 'local happy',
	action: test
}


object.action();
// local happy
```

1. 첫 줄의 target은 전역 변수로 설정
2. this가 object를 가리키므로, 상식적인 코드가 출력

```javascript
target = 'global hanpy';

const test = () => {
	console.log(this.target);
}

const object = {
	target: 'local hanpy',
	action: test
}


object.action();
```

1. 화살표 함수의 경우 내부의 this는 선언한 시점에서 호출
2. target 변수는 전역 설정한 값들이 들어오게 된다.

<br/>

## 함수의 메모리 관점

다시 실행이 불가능한 일회성 함수이기에 그 시점에서만 메모리를 차지하고 없어져 메모리 절약이 가능
<br/>
ex) 버튼 이벤트에 익명함수를 변수에 지정하여 사용했을 시 <br/>
  일반 함수의 경우 참조값이 생겨 브라우저 ```힙``` 메모리에 하나만 저장되지만,<br/>
  익명함수의 경우 매 새로운 메모리를 만들기 때문에 메모리 누수의 위험이 있다고 할 수 있다.

### 1. this 의 개념

- this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가르키는 참조 변수

`함수 내에서 쓴 this`

- 함수 내에서 this는 함수의 주인에게 바인딩이 되는데 이 때는 window 객체가 호출됩니다.
- 하지만 엄격모드에서는 함수 내의 this에 디폴드 바인딩이 없기 때문에 undefined가 호출 됩니다.

`메서드 내에서 쓴 this`

- 매서드 내부 코드에서 사용된 this는 해당 메서드를 호출한 객체로 바인딩 됩니다.

`생성자 내에서 쓴 this`

- 생성자 함수가 생성하는 객체로 this가 바인딩 됩니다.

### 2. 프로토타입 상속이 어떻게 작동이 되는가?

- 객체의 프로퍼티에 접근할 때, 해당 객체에 해당 프로퍼티가 없으면 JS엔진은 객체등을 보고 프로퍼티 정의가 있을 때까지 찾고,<br>
  만약 객체의 프로퍼티에 접근할 때 해당 객체에 해당 프로퍼티가 없으면 포로토타입 체인 중 하나에 있거나 포로토타입 체인의 끝에 <br>
  도달할 때까지 찾습니다.

### 3. null과 undefined의 차이

- `undefined`는 변수는 선언되지만, 값이 할당되지 않은 변수

```javascript
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === "undefined"); // true

console.log(foo == null); // true.

function bar() {}
var baz = bar();
console.log(baz); // undefined
```

- `null`은 값이 명시적으로 할당 된 것으로 값을 나타내지 않으며, 명시적으로 할당됐다는 점에서 `undefined`와 다르다.

```javascript
var foo = null;
console.log(foo === null); // true

console.log(foo == undefined); // true.
```

### 4. 클로저는 무엇이며, 어떻게/왜 사용하는가?

- 내부 함수에서 상위 함수 스코프의 변수에 접근할 수 있는 개념
- 이러한 개념은 이벤트 핸들러로 작업할 때 React에서 자주 사용되는 개념입니다.
- 둘러싸는 함수가 반환된 후에도 함수가 둘러싸는 범위에 정의된 변수에 대해 액세스를 유지할 수 있도록 하기 때문에 중요한 개념.

### 5. `.forEach`와 `.map` 의 차이점

- `forEach`
  - 배열의 요소를 반복하며, 각요소에 대한 콜백을 실행
  - 값을 반환하지 않음
- `map`

  - 배열의 요소를 반복
  - 각요소에서 함수를 호출하여 결과로 새 배열을 작성하여 각 요소를 새 요소에 매핑

- 큰 차이라면 `map`이 새로운 배열을 반환한다는 것이다. <br>
  결과가 필요하지만 원본 배열을 변경하고 싶지 않다면,`map`<br>
  단순히 배열을 반복할 필요가 있다면, `forEach`

### 6. Ajax에 대해 설명하자

- 비동기 웹 응용 프로그램을 만들기 위해 클라이언트 측에서 사용되는 웹개발 기술의 집합
- 사용하면 웹 애플리케이션은 기존 페이지의 화면 및 동작을 방해하지 않으면서 <br>
  백그라운드에서 비동기적으로 서버로 데이터를 보내고 서버에서 데이터를 받아올 수있음
- 상호작용성이 좋아집니다. 서버의 새로운 컨텐츠를 전체 페이지를 다시로드할 필요 없이 동적으로 변경할 수 있습니다.

### 7. 호이스팅에 대해 설명해보세요

- 코드에서 변수 선언의 동작을 설명하는데 사용되는 용어
- `var` 키워드로 선언되거나 초기화된 변수는 현재 스코프의 최상위 까지 옮겨지는데, 이를 `호이스팅` 이라 부릅니다.

### 8. ==와 ===의 차이를 말해보자

- 동등 연산자와 일치 연산자의 큰 차이는 엄격하게 비교를 하느냐에 있다. 동등 연산자는 문자열과 숫자 일 때 타입이 달라도 true <br>
  라는 결과를 반환하지만 일치 연산자는 타입의 동등 여부까지 검사

### 9. `use strict`

- `use strict` 는 전체 스크립트나 개별 함수에 엄격 모드를 사용하는데 사용하는 명령문입니다.

  - 실수로 전역변수를 만드는 것이 불가능합니다.
  - 암묵적으로 실패한 예외를 throw하지 못하는 할당을 만듭니다.
  - 삭제할 수 없는 속성을 삭제하려고 시도합니다. (시도 효과가 없을 때까지)
  - 함수의 매개변수 이름은 고유해야합니다.
  - this는 전역 컨텍스트에서 undefined입니다.
  - 예외를 발생시키는 몇 가지 일반적인 코딩을 잡아냅니다.
  - 헷갈리거나 잘 모르는 기능을 사용할 수 없게 합니다.

### 10. Promise

- 비동기적인 작업을 수행할 때 사용하는 JS객체

  - 비동기작업 : 특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 JS특성을 의미

    - Pending(대기) : Promise 객체를 생성된 상태
    - Fullfilled(이행) : 작업이 성공적으로 수행된 상태
    - Rejected(실패) : 작업이 실패한 상태

  - 장점
    - 가독성이 떨어질 수 있는 콜백 지옥을 피할 수 있습니다.
    - .then()을 이용하여 가독성 좋은 연속적인 비동기 코드를 쉽게 작성할 수 있습니다.

### 11. 동기 비동기 함수의 차이점

- 동기함수에서는 다음 명령문이 실행되기 전에 앞 명령문이 완료 됩니다.
- 비동기는 긴 명령문이 작업을 완료할 때까지 기다리지 않고 다른 작업을 계속 할 수 있는 차이가 있다.

### 12. var, let, cosnt의 차이

- `var`는 중복 선언이 가능하여 에러를 반환하지 않아 문제가 생깁니다.<br>
  이는 호이스팅 때문인데 함수 스코프를 가지며, 변수가 선언되기 전에 코드에서 참조가 됩니다.
- 하지만 `let`,`const`는 이를 허용하지 않고 에러를 빈환하며, 중복 선언이 불가능합니다<br>
  또한 블록스코프를 가지는 선언 방법이며, 변수를 블록 내에서만 접근이 가능합니다.
  `let`은 `const`와 다르게 변수 재할당이 가능합니다.

### 13. 화살표 함수

- `function` 키워드를 사용하지 않고도 함수를 생성하는데 필요한 문법을 단순화하는 것입니다.
- 익명 함수를 할당하는 방식으로, 렉시컬 스코프를 지향하므로 this 바인딩 하지 않아도 된다는 장점이 있다.

### 14. 고차 함수

- 다른 함수를 매개 변수로 사용하여 어떤 데이터를 처리하거나, 결과로 함수를 반환하는 함수
- 반복적으로 수행되는 어떤 연산을 추상화하기 위한 것
- 대표적으로 `map`은 고차 함수를 사용하여 각 항목을 변환하고, 변환된 데이터로 새로운 배열을 반환합니다.

### 15. spread ,와 rest

- 말 그대로 펼치다라는 의미를 가지는데 이는 객체 혹은 배열을 펼칠 수 있습니다.
- 이는 기존의 것을 건들이지 않고 새로운 객체를 만든다는 의미

- rest는 역할이 매우 다르다
- 객체,배열, 그리고 함수의 파라미터에서 사용이 가능

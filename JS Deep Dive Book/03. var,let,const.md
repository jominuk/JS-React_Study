- 키워드를 알기전에

## 1. TDZ

- TDZ(Temporal Dead Zone)는 해석하면 " 일시적 사각지대 "
- 변수가 선언되고 변수의 초기화가 이루어지기 전까지의 구간

![다운로드](https://github.com/jominuk/JS_Study/assets/117640309/4a381291-8004-417a-a169-751e57d24e92)


### 1.2 TDZ의 영향을 받는 구문

1. const 변수

```javascript
❌
console.log(cat)

const cat = "야옹"
//error : ReferenceError
👍
const cat = "야옹"
console.log(cat)

// 출력 : 야옹
```

2. let 변수

```javascript
❌
count;

let count;

count = 10;
//error : ReferenceError
👍
let count;

count; // => undefined

count = 10;

count; // => 10
```

3. class 구문

```javascript
❌
const myCar = new cat('mimi')

class cat {
  constructor(name) {
    this.name = name;
  }

}
//error : ReferenceError
👍
class cat {
  constructor(name) {
    this.name = name;
  }
}
const myCat = new cat('mimi')

console.log(myCat.name) // => mimi
```

### 1.3 TDZ의 영향을 받지 않는 구문

- var, function( 함수 선언식 ), import

```javascript
// Works!
value; // => undefined
var value;
// Works!
hello("Shin"); // "Hello Shin :)"

function hello(name) {
  return `Hello ${name} :)`;
}
hello("Shin"); // "Hello Shin :)"
```

## 2. var키워드로 선언한 변수의 문제점

1. ES6 이전에 사용되던 변수 선언 방법
2. 함수 스코프를 가지며, 변수가 선언된 함수 내에서만 접근 가능
3. 중복선언이 가능하며, 변수 재할당이 가능
4. 호이스팅이 발생하여 선언 전에도 참조 가능

### 2-1. 변수 중복 선언 허용 

```jsx
var x = 1;
var y = 1;

// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용
// 초기화문이 있는 변수 선언문은 JS엔진에 의해 var키워드가 없는 것처럼 동작

var x = 100;
// 초기화문이 없는 변수 선언문은 무시된다

var y;

console.log(x); // 100
console.log(y); // 1
```

- 이처럼 동일한 이름의 변수가 이미 선언되어 있는 것을 모르고 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수 값이 변경되는 부작용이 발생



### 2-2 함수 레벨 스코프 

- var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정
```jsx
var x = 1;

if(true) {
  // x는 전역 변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복선언 된다.
  // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

### 2-3 변수 호이스팅

- var키워드로 변수를 선언하면 변수 호이스팅에 의해 var키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다.
- 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.

```jsx
// 이 시점에는 변수 호이스팅에 의해 이미 foo 변수가 선언되었다 (1.선언단계)
// 변수 foo는 undefined로 초기화된다 (2.초기화 단계)
console.log(foo); //undefined

// 변수에 값을 할당(3. 할당단계)
foo = 123;

console.log(foo); // 123

//변수 선언은 런타임 이전에 JS 엔진에 의해 암묵적으로 실행

var foo;
```

- 이로인해 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만,
- 프로그램의 흐름상 맞지 않고 ```가독성```을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.
- 변수와 함수의 할당 부분은 아직 메모리에 할당되지 않으므로 undefined 값이 할당


















